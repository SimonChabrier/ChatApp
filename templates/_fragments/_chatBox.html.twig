{# ici je peux utiliser une balise template ça s'y prête bien #}
<div id="appendChatBox"></div>

{% if app.user %}
{% block javascripts %}
<script>

// paramètres généraux accèssibles partout
const appUser = {{ app.user.id }};
const appUserName = "{{ app.user.username}}";   

let invitationSend = false;
let invitationEventSource = null;
console.log('invitationEventSource Initial : ' + invitationEventSource);
let chatEventSource = null;
let conversationFromDataBase = null;


//// test appel méthodes
createDomChatBox();
createOnePrivateTopicForEachUser();
checkInvitationEventSourceStatus();
listenInvitationEventSourceActions();
newConversationAlert(); // attention à l'ordre des méthodes l'eventSource doit être créé avant d'être écouté

//////
function createDomChatBox(){
    // on crée la chatbox
    let chatBox = document.createElement('div');
    let closeChatBox = document.createElement('span');
    let chatBoxBody = document.createElement('div');
    let inputBlock = document.createElement('div');
    let chatBoxInput = document.createElement('input');
    let sendPrivateMessage = document.createElement('button');

    chatBox.setAttribute('id', 'chatBox');
    closeChatBox.setAttribute('id', 'closeChatBox');
    closeChatBox.setAttribute('data-chatbox', 'chatBox'); //dataset
    closeChatBox.innerHTML = 'X';
    chatBoxBody.setAttribute('id', 'chatBoxBody');
    inputBlock.setAttribute('class', 'inputBlock');
    chatBoxInput.setAttribute('id', 'chatBoxInput');
    chatBoxInput.setAttribute('type', 'text');
    sendPrivateMessage.setAttribute('id', 'sendPrivateMessage');
    sendPrivateMessage.setAttribute('class', 'btn btn-sm btn-success');
    sendPrivateMessage.setAttribute('type', 'submit');
    sendPrivateMessage.innerHTML = 'Send';

    inputBlock.appendChild(chatBoxInput);
    inputBlock.appendChild(sendPrivateMessage);
    chatBox.appendChild(closeChatBox);
    chatBox.appendChild(chatBoxBody);
    chatBox.appendChild(inputBlock);

    document.getElementById('appendChatBox').appendChild(chatBox)
}
/////
function createOnePrivateTopicForEachUser (){
    
    const usersLinkPrivateTopics = [];

    const connectedUsers = document.querySelectorAll('.connectedUser');
    
    connectedUsers.forEach((user) => {

        const userId = user.getAttribute('data-id');
        const topic = `private-conversation=${userId}`;
        usersLinkPrivateTopics.push(topic);
        
    });

    connectedUsers.forEach((user) => {
        
        user.addEventListener('click', (e) => {
            e.preventDefault();  
            // on lance la conversation avec l'utilisateur cliqué          
            startConversation(user.getAttribute('data-id'));
        });
    });

    const userTopicLink = usersLinkPrivateTopics.filter((topic) => {
        const regex = new RegExp(`^private-conversation=${appUser}$`);
        return regex.test(topic);
    });

    console.log('contenu du tableau de lien de topic de chaque utilisateur : ' + usersLinkPrivateTopics);

    const link = 'https://mercure.simschab.cloud/.well-known/mercure';
    const url = new URL(link);
    url.searchParams.append('topic', `${userTopicLink}`);

    invitationEventSource = new EventSource(url);
}
///
function startConversation(userId) {
    
    // à l'appel de startConversation dans createOnePrivateTopicForEachUser on a récupré l'id de l'utilisateur que lequel on a cliqué    
    
    if (invitationSend === false ) {
        
        fetch('/conversation', {
        method: 'POST',
        body: JSON.stringify({ participants: [ userId ] }),
        headers: {
            'Content-Type': 'application/json'
        }
        })
        .then(response => { 
            return response.json(); // le conversation arrive ici depuis le controller et la bdd
        })
        .then(data => {
            conversation = data.conversation;
            sendInvitation(userId, conversation);
        })
        .catch(error => {
            console.error(error);
        });

            // on passe l'invitationSend à true pour ne pas pouvoir envoyer plusieurs invitations à la fois à un même utilisateur il faut vérifier l'id de l'utilisateur cliqué et l'id de l'utilisateur connecté pour ne pas pouvoir s'inviter soi-même et ne pas pouvoir envoyer plusieurs invitations à un même utilisateur mais autoriser plusieurs invitations à plusieurs utilisateurs différents
            
            invitationSend = true;

    } else {
        console.log('invitation déjà envoyée');
    }

    return
};
///
function sendInvitation(userId, conversation){

    const invitationHubMessage = {
        topic: `private-conversation=${userId}`, 
        // on cible le topic de l'utilisateur cliqué
        message: conversation 
        // on lui envoie la conversation de la bdd qu'on a reçu dans startConversation
    };

    fetch('/ask/conversation', {
    method: 'POST',
    body: JSON.stringify(invitationHubMessage),
    // envoyer le message et le topic pour le publier sur le hub et le diffuser aux abonnés
    })
    .then(
        response => console.log(response.conversation),
        )
    .then(data => {
        //console.log(data);
        //openChatBox(conversation);
    })
    .catch(error => {
        console.error(error);
    });
};



///
function newConversationAlert(){
    // on écoute les messages envoyés par le hub
    invitationEventSource.onmessage = event => {

    alert('invitationEventAlert - onmessage : ' + event.data);
    
        if(event.data){
            const data = JSON.parse(e.data);
            conversationFromDataBase = data.conversation;
        }
        
    };
}
///
function checkInvitationEventSourceStatus(){
    // contrôle de l'état de l'eventSource pour évaluer les actions à mener
    switch(invitationEventSource.readyState){
        case 0:
            console.log('invitationEventSource.readyState === 0 (CONNECTING)');
            break;
        case 1:
            console.log('invitationEventSource.readyState === 1 (OPEN)');
            break;
        case 2:
            console.log('invitationEventSource.readyState === 2 (CLOSED)');
            break;
        case 3:
            console.log('invitationEventSource.readyState === 3 (DISCONNECTED)');
            break;
        default:
            console.log('Error: Unknown readyState value');
            break;
    }
}
///
function listenInvitationEventSourceActions(){
    // controle de l'état de l'eventSource pour réagir aux actions
    
    invitationEventSource.onopen = function(event) {
        console.log('Connection opened. ReadyState = ' + invitationEventSource.readyState);
    };
    invitationEventSource.onmessage = function(event) {
        //console.log('Message received: ' + event.data);
    };
    invitationEventSource.onclose = function(event) {
        console.log('Connection closed. ReadyState = ' + invitationEventSource.readyState);
    };
     invitationEventSource.onerror = function(event) {
        console.log('Error: EventSource error occurred. ReadyState = ' + invitationEventSource.readyState);
    };
}
</script>
{% endblock %}
{% endif %}

