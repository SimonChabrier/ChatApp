{# ici je peux utiliser une balise template ça s'y prête bien #}
<div id="chatBox">
    <span id="closeChatBox">X</span>
    <div id="chatBoxBody"></div>
    <div class="inputBlock">
        <input id="chatBoxInput" type="text">
        <button id="sendPrivateMessage" class="btn btn-sm btn-success" type="submit">Send</button>
    </div>
</div>

{% if app.user %}

{% block javascripts %}
<script>

//////// EN COURS DE DEV NOTIF PRIVEE IL FAUDRA RAFRAICHIR LE TABLEAU DES TOPICS A CHAQUE CONNECTION / DECONNECTION //////////

///////////////// On crée les topics privés pour chaque utilisateur connecté ///////////////////////

document.addEventListener('DOMContentLoaded', (evt) => {

    console.log('DOM chargé');

//// INIT


//* 0 - on récupère l'id et le nom de l'utilisateur connecté en session

    const appUser = {{ app.user.id }};
    const appUserName = '{{ app.user.username}}';
    

//* 1 - on crée la liste potentielle de tous les topics qui peuvent exister en fonction des utilisateurs connectés.


    const topics = [];
    // On récupère la liste d'utilisateurs connectés dans le DOM
    const connectedUsers = document.querySelectorAll('.connectedUser');
    // on récupère le data-set de chaque utilisateur connecté
    connectedUsers.forEach((user) => {
        // on récupère l'id de l'utilisateur sur l'attibut data-id de chaque utilisateur de la liste
        const userId = user.getAttribute('data-id');
        // on crée un topic privé pour chaque utilisateur connecté
        const topic = `private-conversation=${userId}`;
        // on ajoute le topic à la liste des topics privés
        topics.push(topic);
    });

    chooseUserInUserList(connectedUsers);
   
//* 2 - On abonne chaque utilisateur en seesion au topic privé qui le concerne


    const userTopicLink = topics.filter((topic) => {
        // on filtre la liste des topics pour ne garder que ceux qui concernent l'utilisateur connecté
        const regex = new RegExp(`^private-conversation=${appUser}$`);
        return regex.test(topic);
    });

    //console.log(userTopicLink);


//* 3 - On crée la souscription de l'utilisateur à son topic privé


    const link = 'https://mercure.simschab.cloud/.well-known/mercure';
    const url = new URL(link);
    url.searchParams.append('topic', `${userTopicLink}`);
    const eventSource = new EventSource(url);


//* 4 - On écoute les messages reçus du hub


    eventSource.onmessage = e => {

        // le chatController retourne la conversation envoyée en message dans le hub par l'utilisateur qui invite
        // L'utilisateur qui invite reçoit en réponse du ConversationCOntroller la conversation existant ou crée pour lui et l'utilisateur invité
        // la poste au hub pour que l'utilisateur invité la reçoive avec l'invitation et l'affiche dans son chatbox
        
        const data = JSON.parse(e.data);
        const conversation = data.conversation

        // ici on a les données de la conversation envoyée par le hub
        // on le passe donc à la chatbox pour l'afficher à l'utilisateur invité
        // en même temps on l'affiche à l'utilisateur qui invite
        // en l'état initial
        openChatBox(conversation);
    };


//* 5 - On écoute les clics sur les utilisateurs connectés pour envoyer un message privé à l'utilisateur cliqué


function chooseUserInUserList(connectedUsers) {

    connectedUsers.forEach((user) => {

        console.log(user);
        
        user.addEventListener('click', (e) => {

            console.log('click');

            e.preventDefault();

            // ici il faut que je récupère la conversation d'abord avec le user cliqué et une promesse
            // je récupère l'id de l'utilisateur cliqué pour l'envoyer au back.
            startConversation(user.getAttribute('data-id'));

        });
    });
}

function sendInvitation(userId, conversation){

    // on envoie l'invit et la conversation au hub pour que l'utilisateur invité la reçoive
    
    // on prépare le message à envoyer    
    const data = {
        // on récupère l'id de l'utilisateur cliqué qui correspond au topic privé auquel cet utilisateur est abonné
        topic: `private-conversation=${userId}`,
        message: conversation // j'envoi la conversation pour l'afficher dans le chatbox de l'utilisateur cliqué
    };

        // on poste un message privé à l'utilisateur cliqué via mercure qui recevra la notification
        fetch('/ask/conversation', {
        method: 'POST',
        body: JSON.stringify(data),// envoyer le message et le topic pour le publier sur le hub et le diffuser aux abonnés
        })
       .then(response => response.text())
        .then(data => {
            // ici je reçoit le retour du controller il faut que je récupère la conversation et que je l'ouvre pour tout le monde.
            openChatBox(conversation);
            console.log(data);
        })
        .catch(error => {
            console.error(error);
        });
}



/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
/////////////////////////////////



 function startConversation(userId){
    
    // userId est l'id de l'utilisateur sur le quel on a clliqué dans le liste pour lui envoyer un message privé
    // via le hub mercure dans sendInvitation sur la route /ask/conversation qui va envoyer un message privé à l'utilisateur cliqué
    // qui arrive dans le onmessage() de l'enventSource.onmessage = e => {} du hub mercure
    
    fetch('/conversation', {
    method: 'POST',
    body: JSON.stringify({ participants: [ userId ] }), // ici je passe un array parce que dans le bac on fait un count sur le nombre d'éléments dans le tableau pour si le nombre de participants invités est conforme au nombre de participants attendus
    headers: {
        'Content-Type': 'application/json'
    }
    })
    .then(response => {
    if (!response.ok) {
        throw new Error('Erreur lors de la récupération des données');
    }
    return response.json();
    })
    .then(data => {
        console.log(data.conversation);

        // ici on a la conversation appartenant aux deux utlisateurs récupérée par leur ID sur la custom request de conversationRepository
        // elle  est retournée par le controller sur la route /conversation après toute la série de vérifications de l'algorithme.
        
        // j'invite donc l'autre utilisateur en lui retournant la conversation récupérée et une notification qui va ouvrir sa chatbox
        sendInvitation(userId, data.conversation);
    })
    .catch(error => {
        console.error(error);
    });
 }   


/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
///////////////////////////////// 29 AVRIL PUBLICATION MESSAGE PRIVÉ
///////////////// PUBLICATION DU NOUVEAU MESSAGE PRIVE SUR MERCURE //////////////////
function conversationPublish(conversation) {

    console.log('publish');

    const sessionUserId = parseInt('{{ app.user.id }}');
    const otherUserId = conversation.users.find( user => parseInt(user.id) !== sessionUserId);
    const conversationId = conversation.id;
    
    document.getElementById('sendPrivateMessage').addEventListener('click', (e) => {

        console.log('click');

        e.preventDefault();
        // on récupère le contenu du message dans l'input
        const message = document.getElementById('chatBoxInput').value;
        
        const data = {  
        
        topic: encodeURIComponent(`conversation/${conversationId}`),
        message: `${message}`,
        conversation_id: `${conversationId}`,
        author_id: `${sessionUserId}`,
        };
        
        fetch('/publish/private', {
            method: 'POST',
            body: JSON.stringify(data),
        })
        .then(response => response.text())
        .then(data => {
            console.log('Message privé envoyé');
            document.getElementById('chatBoxInput').value = '';
        })
        .catch(error => {
            console.error(error);
        });
    });
}
///////////////// SOUSCRIPTION CONVERSATION PRIVEES ET AFFICHAGE DES MESSAGES RECUS //////////////////

// déclarer une variable eventSourceConversation en dehors du bloc if pour
// y accéder plus tard dans toutes les méthodes et l'initialiser avec ce que l'on veut à la volée
let eventSourceConversation = null; 

function conversationSubscribe(id){
    
    console.log(status);
    console.log('souscription à la conversation privée');
    
    const link = 'https://mercure.simschab.cloud/.well-known/mercure';
    const url = new URL(link);
    url.searchParams.append('topic', encodeURIComponent(`conversation/${id}`));
    
    eventSourceConversation = new EventSource(url);
        // réponses de Mercure 
        eventSourceConversation.onmessage = e => { 
            const data = JSON.parse(e.data);
            console.log(data);
            createNewMessageSpan(data);     
        };

    // on autorise la fermeture de la chatbox et on se passe l'onjet eventSource pour pouvoir le fermer
    closeChatBox(eventSourceConversation);

    // on retourne l'event eventSourceConversation 
    return eventSourceConversation
}

///////////////// GESTION AFFICHAGE DU CHAT /////////////////////

function openChatBox(conversation) {

    // on récupère l'envent source actif pour qu epersonne n'y souscrive deux fois
    let currentEventSource = conversationSubscribe(conversation.id);
    // on traite les chaines de caractères pour pouvoir les comparer (les paramètres de l'url sont encodés et on veut les comparer avec les paramètres de l'url au format string non encodé)
    // on décode l'url de l'eventSource actuel et on extraie les paramètres de l'url puis on encode les paramètres de l'url de la conversation actuelle
    console.log(decodeURIComponent(currentEventSource.url).split('=')[1] === encodeURIComponent(`conversation/${conversation.id}`));

    if (conversation && decodeURIComponent(currentEventSource.url).split('=')[1] === encodeURIComponent(`conversation/${conversation.id}`)) {
    
    const chatBox = document.getElementById('chatBox');
    //console.log(conversation.users);
    
    chatBox.dataset.conversationId = conversation.id;

        for(let i = 0; i < conversation.users.length; i++) {
            //on ajoute les Id des participants à la conversation dans le dataset de la chatbox
            chatBox.dataset[`user${i+1}Id`] = conversation.users[i].id;
        }
        chatBox.dataset.user1Id = conversation.users[0].id;
        chatBox.dataset.user2Id = conversation.users[1].id;
        
        chatBox.style.display = 'block';

        for (opacity = 0; opacity < 1.1; opacity = opacity + 0.1) {           
            setTimeout(function(){chatBox.style.opacity = opacity;},150)                       
        } 
    
    //conversationSubscribe(conversation.id);
    // on autorise la publication de message privé sur mercure
    conversationPublish(conversation);

    } else {
        console.log('conversation interdite');
    }
}

function closeChatBox(eventSourceConversation) {

    const chatBox = document.getElementById('chatBox');
    
    document.getElementById('closeChatBox').addEventListener('click', (e) => {
        
        e.preventDefault();

        eventSourceConversation.close();

        if (e.target.id === 'closeChatBox') {
            for (let opacity = 1; opacity > -0.1; opacity -= 0.1) {           
                setTimeout(() => {
                    chatBox.style.opacity = opacity;
                }, 150);
            } 
            setTimeout(() => {
                chatBox.style.display = 'none';

                // clean chatbox content
                const chatBoxBody = document.getElementById('chatBoxBody');
                chatBoxBody.innerHTML = '';

            }, 150);
        }
    });
}

function createNewMessageSpan (data) {

    const chatBoxBody = document.getElementById('chatBoxBody');

    const span = document.createElement('span');

    span.classList.add('private_message');

        if (data.author_id === {{ app.user.id }}) {
            span.style.float = 'right';
            span.style.backgroundColor = '#cbffd6';
        } else {
            span.style.float = 'left';
        }

    // on ajoute les données retournées par Mercure dans la réponse sur le DOM
    span.innerText = `${data.message}`;
    chatBoxBody.appendChild(span, chatBoxBody.lastElementChild); 
}



}); //  end dom loaded

</script>
{% endblock %}
{% endif %}

