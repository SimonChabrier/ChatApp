{# ici je peux utiliser une balise template ça s'y prête bien #}
<div id="chatBox">
    <span id="closeChatBox">X</span>
    <div id="chatBoxBody"></div>
    <div class="inputBlock">
        <input id="chatBoxInput" type="text">
        <button id="sendPrivateMessage" class="btn btn-sm btn-success" type="submit">Send</button>
    </div>
</div>

{% if app.user %}

{% block javascripts %}
<script>

//////// EN COURS DE DEV NOTIF PRIVEE IL FAUDRA RAFRAICHIR LE TABLEAU DES TOPICS A CHAQUE CONNECTION / DECONNECTION //////////

///////////////// On crée les topics privés pour chaque utilisateur connecté ///////////////////////

document.addEventListener('DOMContentLoaded', (evt) => {

    console.log('DOM chargé');

//// INIT


//* 0 - on récupère l'id et le nom de l'utilisateur connecté en session

    const appUser = {{ app.user.id }};
    const appUserName = '{{ app.user.username}}';
    

//* 1 - on crée la liste potentielle de tous les topics qui peuvent exister en fonction des utilisateurs connectés.


    const topics = [];
    // On récupère la liste d'utilisateurs connectés dans le DOM
    const connectedUsers = document.querySelectorAll('.connectedUser');
    // on récupère le data-set de chaque utilisateur connecté
    connectedUsers.forEach((user) => {
        // on récupère l'id de l'utilisateur sur l'attibut data-id de chaque utilisateur de la liste
        const userId = user.getAttribute('data-id');
        // on crée un topic privé pour chaque utilisateur connecté
        const topic = `private-conversation=${userId}`;
        // on ajoute le topic à la liste des topics privés
        topics.push(topic);
    });

    chooseUserInUserList(connectedUsers);
   
//* 2 - On abonne chaque utilisateur en seesion au topic privé qui le concerne


    const userTopicLink = topics.filter((topic) => {
        // on filtre la liste des topics pour ne garder que ceux qui concernent l'utilisateur connecté
        const regex = new RegExp(`^private-conversation=${appUser}$`);
        return regex.test(topic);
    });

    //console.log(userTopicLink);


//* 3 - On crée la souscription de l'utilisateur à son topic privé


    const link = 'https://mercure.simschab.cloud/.well-known/mercure';
    const url = new URL(link);
    url.searchParams.append('topic', `${userTopicLink}`);
    const eventSource = new EventSource(url);


//* 4 - On écoute les messages reçus du hub


    eventSource.onmessage = e => {
        console.log(e.data);
        openChatBox(e.data);
    };


//* 5 - On écoute les clics sur les utilisateurs connectés pour envoyer un message privé à l'utilisateur cliqué


function chooseUserInUserList(connectedUsers) {

    connectedUsers.forEach((user) => {

        console.log(user);
        
        user.addEventListener('click', (e) => {

            console.log('click');

            e.preventDefault();

            // ici il faut que je récupère la conversation d'abord avec le user cliqué et une promesse
            // je récupère l'id de l'utilisateur cliqué pour l'envoyer au back.
            //post(user.getAttribute('data-id'));

            // ensuite part dans 

            sendFrontNotification(user);


            // initialiser la fenêtre de chat avec l'id de la conversation pour lui et pour moi
            // une fois que j'ai la conversation je peux envoyer le message privé à l'utilisateur cliqué

            

        });
    });
}

function sendFrontNotification(user){

    // on récupère l'id de l'utilisateur cliqué
    const userId = user.getAttribute('data-id');
    
    // on prépare le message à envoyer    
    const data = {
        // on récupère l'id de l'utilisateur cliqué qui correspond au topic privé auquel cet utilisateur est abonné
        topic: `private-conversation=${userId}`,
        message: `Message reçu de l\'utilisateur : ${appUserName}`,
    };

        // on poste un message privé à l'utilisateur cliqué via mercure qui recevra la notification
        fetch('/ask/conversation', {
        method: 'POST',
        body: JSON.stringify(data),// envoyer le message et le topic pour le publier sur le hub et le diffuser aux abonnés
        })
       .then(response => response.text())
        .then(data => {
            console.log(data);
        })
        .catch(error => {
            console.error(error);
        });
}



/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
/////////////////////////////////



 function post(userId){
    
    // Envoyer une requête fetch à la route /conversation avec l'ID de l'utilisateur sélectionné
    
    fetch('/conversation', {
    method: 'POST',
    body: JSON.stringify({ participants: [ userId ] }), // ici je passe un array parce que dans le bac on fait un count sur le nombre d'éléments dans le tableau pour si le nombre de participants invités est conforme au nombre de participants attendus
    headers: {
        'Content-Type': 'application/json'
    }
    })
    .then(response => {
    if (!response.ok) {
        throw new Error('Erreur lors de la récupération des données');
    }
    return response.json();
    })
    .then(data => {
        console.log(data);
        // ici il faut que je m'ouvre la chatbox avec le bon topic
        const chatBoxId = data.conversation._id; // Récupérer l'ID de la conversation créée
        openChatBox(chatBoxId);


    })
    .catch(error => {
        console.error(error);
    });
 }   


/////////////////////////////////
/////////////////////////////////
/////////////////////////////////
///////////////////////////////// 29 AVRIL PUBLICATION MESSAGE PRIVÉ
///////////////// PUBLICATION DU NOUVEAU MESSAGE PRIVE SUR MERCURE //////////////////
function pub(conversation) {
    const sessionUserId = parseInt('{{ app.user.id }}');
    const otherUserId = conversation.users.find( user => parseInt(user.id) !== sessionUserId);
    const conversationId = conversation.id;
    
    document.getElementById('sendPrivateMessage').addEventListener('click', (e) => {
        e.preventDefault();
        // on récupère le contenu du message dans l'input
        const message = document.getElementById('chatBoxInput').value;
        
        const data = {  
        
        topic: encodeURIComponent(`conversation/${conversationId}`),
        message: `${message}`,
        conversation_id: `${conversationId}`,
        author_id: `${sessionUserId}`,
        };
        
        fetch('/publish/private', {
            method: 'POST',
            body: JSON.stringify(data),
        })
        .then(response => response.text())
        .then(data => {
            console.log('Message privé envoyé');
            document.getElementById('chatBoxInput').value = '';
        })
        .catch(error => {
            console.error(error);
        });
    });
}


///////////////// GESTION AFFICHAGE DU CHAT /////////////////////

function openChatBox(data) {
    const chatBox = document.getElementById('chatBox');
    console.log('on affiche la chatbox');
    //chatBox.dataset.conversationId = data.conversation.id;
    //for(let i = 0; i < data.conversation.users.length; i++) {
        //on ajoute les Id des participants à la conversation dans le dataset de la chatbox
      //  chatBox.dataset[`user${i+1}Id`] = data.conversation.users[i].id;
    //}
    //chatBox.dataset.user1Id = data.conversation.users[0].id;
    //chatBox.dataset.user2Id = data.conversation.users[1].id;
    
    chatBox.style.display = 'block';
    for (opacity = 0; opacity < 1.1; opacity = opacity + 0.1) {           
        setTimeout(function(){chatBox.style.opacity = opacity;},150)                       
    } 

    // on autorise la fermeture de la chatbox
    closeChatBox();
}

function closeChatBox() {
    
    const chatBox = document.getElementById('chatBox');
    
    document.getElementById('closeChatBox').addEventListener('click', (e) => {
        
        if (e.target.id === 'closeChatBox') {
            for (let opacity = 1; opacity > -0.1; opacity -= 0.1) {           
                setTimeout(() => {
                    chatBox.style.opacity = opacity;
                }, 150);
            } 
            setTimeout(() => {
                chatBox.style.display = 'none';
            }, 150);
        }
    });
}

function createNewMessageSpan (data) {

    const chatBoxBody = document.getElementById('chatBoxBody');

    const span = document.createElement('span');

    span.classList.add('private_message');

        if (data.author_id === {{ app.user.id }}) {
            span.style.float = 'right';
            span.style.backgroundColor = '#cbffd6';
        } else {
            span.style.float = 'left';
        }

    // on ajoute les données retournées par Mercure dans la réponse sur le DOM
    span.innerText = `${data.message}`;
    chatBoxBody.appendChild(span, chatBoxBody.lastElementChild); 
}



}); //  end dom loaded

</script>
{% endblock %}
{% endif %}

