{# ici je peux utiliser une balise template ça s'y prête bien #}
<div id="chatBox">
    <span id="closeChatBox">X</span>
    <div id="chatBoxBody"></div>
    <div class="inputBlock">
        <input id="chatBoxInput" type="text">
        <button id="sendPrivateMessage" class="btn btn-sm btn-success" type="submit">Send</button>
    </div>
</div>

{% if app.user %}

{% block javascripts %}
<script>

///////////////// On crée les topics privés pour chaque utilisateur connecté ///////////////////////

document.addEventListener('DOMContentLoaded', (evt) => {

    console.log('DOM chargé');

//* 0 - on récupère l'id et le nom de l'utilisateur connecté en session

    const appUser = {{ app.user.id }};
    const appUserName = '{{ app.user.username}}';
    

//* 1 - on crée la liste potentielle de tous les topics qui peuvent exister en fonction des utilisateurs connectés.

    const topics = [];
    const connectedUsers = document.querySelectorAll('.connectedUser');
    connectedUsers.forEach((user) => {
        const userId = user.getAttribute('data-id');
        const topic = `private-conversation=${userId}`;
        topics.push(topic);
    });

   chooseUserInUserList(connectedUsers);

   
//* 2 - On abonne chaque utilisateur en session au topic privé qui le concerne uniqument (son topic privé)

    const userTopicLink = topics.filter((topic) => {
        // on filtre la liste des topics pour ne garder que ceux qui concernent l'utilisateur connecté
        const regex = new RegExp(`^private-conversation=${appUser}$`);
        return regex.test(topic);
    });

//* 3 - On crée la souscription de l'utilisateur à son topic privé


    const link = 'https://mercure.simschab.cloud/.well-known/mercure';
    const url = new URL(link);
    url.searchParams.append('topic', `${userTopicLink}`);
    const eventSource = new EventSource(url);


//* 4 - On écoute les messages reçus du hub

    eventSource.onmessage = e => {
        
        const data = JSON.parse(e.data);
        const conversation = data.conversation;
        openChatBox(conversation);
    };


//* 5 - On écoute les clics sur les utilisateurs connectés pour envoyer un message privé à l'utilisateur cliqué
function chooseUserInUserList(connectedUsers) {

    connectedUsers.forEach((user) => {
        
        user.addEventListener('click', (e) => {
            e.preventDefault();
            setConversation(user.getAttribute('data-id'));

        });
    });
};


//* 6 - On démarrer la conversation avec l'utilisateur cliqué


function setConversation(userId) {

    fetch('/conversation', {
    method: 'POST',
    body: JSON.stringify({ participants: [ userId ] }), 
    headers: {
        'Content-Type': 'application/json'
    }
    })
    .then(response => {
    if (!response.ok) {
        throw new Error('Erreur lors de la récupération des données');
    }
    return response.json();
    })
    .then(data => {

        setChatBox(data);
        sendInvitation(userId, data.conversation);

    })
    .catch(error => {
        console.error(error);
    });
};

//* 7 - On initialize le contenu de la chatbox avec la conversation initiale de la base de données

function setChatBox(data){
    
    let conversation = data.conversation;

    if(conversation.messages.length > 0){

        conversation.messages.forEach(message => {

        const span = document.createElement('span');
        span.classList.add('private_message');

        if (conversation.users[0].id === '{{ app.user.id }}' ) {
            span.style.float = 'right';
            span.style.backgroundColor = '#cbffd6';
        } else {
            span.style.float = 'left';
        }

        span.innerText = message.content;
        chatBoxBody.appendChild(span);
        });

    }
};

//* 8 - On envoie l'invitation à l'utilisateur cliqué

function sendInvitation(userId, conversation){
 
    const data = {
        topic: `private-conversation=${userId}`,
        message: conversation 
    };

    fetch('/ask/conversation', {
    method: 'POST',
    body: JSON.stringify(data),
    })
    .then(response => response.text())
    .then(data => {
        
        //* 9 - On ouvre la chatbox de l'utilisateur cliqué
        openChatBox(conversation);
    })
    .catch(error => {
        console.error(error);
    });
};


///////////////// PUBLICATION DU NOUVEAU MESSAGE PRIVE SUR MERCURE //////////////////
function conversationPublish(conversation) {

    // open current event source
    let currentEventSource = conversationSubscribe(conversation.id);
    

    console.log('publish');

    const sessionUserId = parseInt('{{ app.user.id }}');
    const otherUserId = conversation.users.find( user => parseInt(user.id) !== sessionUserId);
    const conversationId = conversation.id;
    
    document.getElementById('sendPrivateMessage').addEventListener('click', (e) => {

        e.preventDefault();

        const message = document.getElementById('chatBoxInput').value;

        // TODO gèrer si le message est vide ajouter un message d'erreur dans une div
        
        const data = {  
        
        topic: encodeURIComponent(`conversation/${conversationId}`),
        message: `${message}`,
        conversation_id: `${conversationId}`,
        author_id: `${sessionUserId}`,
        };
        
        fetch('/publish/private', {
            method: 'POST',
            body: JSON.stringify(data),
        })
        .then(response => response.text())
        .then(data => {
            console.log('Message privé envoyé');
            document.getElementById('chatBoxInput').value = '';
        })
        .catch(error => {
            console.error(error);
        });
    });
};
///////////////// SOUSCRIPTION CONVERSATION PRIVEES ET AFFICHAGE DES MESSAGES RECUS //////////////////

let eventSourceConversation = null; 

function conversationSubscribe(id){

    console.log('souscription à la conversation privée');
    
    const link = 'https://mercure.simschab.cloud/.well-known/mercure';
    const url = new URL(link);
    url.searchParams.append('topic', encodeURIComponent(`conversation/${id}`));
    
    eventSourceConversation = new EventSource(url);
        // réponses de Mercure 
        eventSourceConversation.onmessage = e => { 
            const data = JSON.parse(e.data);
            createNewMessageSpan(data);     
        };

    // on autorise la fermeture de la chatbox et on se passe l'onjet eventSource pour pouvoir le fermer
    closeChatBox(eventSourceConversation);
    // on retourne l'event eventSourceConversation 
    return eventSourceConversation
};

///////////////// GESTION AFFICHAGE DU CHAT /////////////////////

function openChatBox(conversation) {

     createNewMessageSpan(conversation.messages)

    // on récupère l'envent source actif et on le ferme pour en ouvrir un nouveau à la volée sur la publication du message privé dans conversationPublish()
    let currentEventSource = conversationSubscribe(conversation.id);

    currentEventSource.close();

    if (conversation && decodeURIComponent(currentEventSource.url).split('=')[1] === encodeURIComponent(`conversation/${conversation.id}`)) {
    
    const chatBox = document.getElementById('chatBox');
    //console.log(conversation.users);
    
    chatBox.dataset.conversationId = conversation.id;

        for(let i = 0; i < conversation.users.length; i++) {
            chatBox.dataset[`user${i+1}Id`] = conversation.users[i].id;
        }
        chatBox.dataset.user1Id = conversation.users[0].id;
        chatBox.dataset.user2Id = conversation.users[1].id;
        
        chatBox.style.display = 'block';

        for (opacity = 0; opacity < 1.1; opacity = opacity + 0.1) {           
            setTimeout(function(){chatBox.style.opacity = opacity;},150)                       
        } 
    
    conversationPublish(conversation);

    } else {
        console.log('conversation interdite');
    }
};

function closeChatBox(eventSourceConversation) {

    const chatBox = document.getElementById('chatBox');
    
    document.getElementById('closeChatBox').addEventListener('click', (e) => {
        
        e.preventDefault();

        // on ferme l'eventSource
        eventSourceConversation.close();

        if (e.target.id === 'closeChatBox') {
            for (let opacity = 1; opacity > -0.1; opacity -= 0.1) {           
                setTimeout(() => {
                    chatBox.style.opacity = opacity;
                }, 150);
            } 
            setTimeout(() => {
                chatBox.style.display = 'none';
                const chatBoxBody = document.getElementById('chatBoxBody');
                chatBoxBody.innerHTML = '';

            }, 150);
        }
    });
};

function createNewMessageSpan (data) {

    if(data.message !== undefined){

    const chatBoxBody = document.getElementById('chatBoxBody');

    const span = document.createElement('span');

    span.classList.add('private_message');

        if (data.author_id === {{ app.user.id }}) {
            span.style.float = 'right';
            span.style.backgroundColor = '#cbffd6';
        } else {
            span.style.float = 'left';
        }
    span.innerText = `${data.message}`;
    chatBoxBody.appendChild(span, chatBoxBody.lastElementChild); 

    }

};

}); //  end dom loaded

</script>
{% endblock %}
{% endif %}

