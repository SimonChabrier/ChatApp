<aside>
<div>
    <h2>ChatRooms</h2>
</div>

{# on ajoute la liste des utilisateurs connectés #}
<div class="mb-3">
{% if twig_globals.getGlobals()['online_users'] is not empty %}
    <ul class ="user_connected_list">
    {% for online_user in twig_globals.getGlobals()['online_users'] %}
        <li data-id={{ online_user.id  }}>{{ online_user.username }} : online</li>
    {% endfor %}
    {% else %}
    <li>
        Aucun utilisateur connecté
    </li>
{% endif %}
    </ul>
</div>


<div>
{% if twig_globals.getGlobals()['all_channels'] is not empty %}
    <ul class="notifList">
    {% for channel in twig_globals.getGlobals()['all_channels'] %}
        <li>
            <a href="{{ path('app_channel_show', {'id': channel.id}) }}">{{ channel.name }}</a>
            <span class="notifCount" id="notifCount_{{ channel.id }}" data-count=0></span>
            {# on prepare une span pour le nombre de notif...à gèrer en js 
            et renvoyer les notifs depuis le controller...#}
        </li>
    {% endfor %}
    {% else %}
        <li>
            <a href="{{ path('app_channel_new') }}">Créer un nouveau chat</a>
        </li>
    {% endif %}
    </ul>
</div>
</aside>

{% block javascripts %}

<script>
    /////////////////
    const topicslink = new URL('https://mercure.simschab.cloud/.well-known/mercure');
    topicslink.searchParams.append('topic', encodeURIComponent('user_connected'));
    topicslink.searchParams.append('topic', encodeURIComponent('user_disconnected'));
    // on peut imaginer ajouter d'autres topics pour les messages, les channels, etc...    
    const usersEventSource = new EventSource(topicslink);

    const usersConnectedList = document.querySelector('.user_connected_list');
    console.log(usersConnectedList);

    usersEventSource.onmessage = (e) => {
        const data = JSON.parse(e.data);
        console.log(data);
        if (data.status === 'online') {

            // cause we have boot a request from users status in database to not clear list on page change 
            // and a direct request from mercure to update the list when a user connect or disconnect
            // check fist if the user is already in the list for not adding it twice in the list

            // si on change de page ou en arrivant sur l'interface on va avoir la liste des utilisateurs connectés via la varibale globale twig et la requete en bdd
            // donc on ne veut pas faire de doublon avec la liste des utilisateurs qui se connectent et aussi ne pas perdre les utilisateurs qui se connectent si on change de page...
            const liAlreadyInList = usersConnectedList.querySelector(`li[data-id="${data.user_id}"]`);
            if (liAlreadyInList) {
                return;
            }

            const li = document.createElement('li');
            li.textContent = data.username + ' : ' + data.status;
            li.dataset.id = data.user_id;
            usersConnectedList.appendChild(li);
        } else if (data.status === 'offline') {
            const li = usersConnectedList.querySelector(`li[data-id="${data.user_id}"]`);
            li.remove();
        }
    };

///////////////// Channels notifications using mercure in a loop on all channels ////////////////

// get id from url to know which channel is currently displayed
{% if app.request.get('id') is not null %}
    const currentChannelId = {{ app.request.get('id') }};
{% else %}
    const currentChannelId = null;
{% endif %}

{% if twig_globals.getGlobals()['all_channels'] is not empty %}

{% for channel in twig_globals.getGlobals()['all_channels'] %}
    // Est ce que le channel actuellement affiché est différent de celui de la boucle ?
    if ({{ channel.id }} !== currentChannelId || currentChannelId === null) {
        // on ajoute un event source pour chaque channel différent de celui actuellement affiché
        const notifSource{{ channel.id }} = new EventSource('https://mercure.simschab.cloud/.well-known/mercure?topic=channel/{{ channel.id }}');
        // on récupère la span qui contiendra le nombre de notif
        const notifCount{{ channel.id }} = document.getElementById('notifCount_{{ channel.id }}');
        
        // on écoute les messages envoyés par mercure
        notifSource{{ channel.id }}.onmessage = (event) => {
            const data = JSON.parse(event.data);
            let count = parseInt(notifCount{{ channel.id }}.getAttribute('data-count')) || 0;
            // on incrémente le nombre de notif avec la valeur retournée par mercure à la clé count
            count += 1;
            notifCount{{ channel.id }}.textContent = count;
            notifCount{{ channel.id }}.setAttribute('data-count', count);
            notifCount{{ channel.id }}.classList.remove('hideElement');
            // on stocke le nombre de notif dans le local storage pour pouvoir le récupérer si on change de page
            localStorage.setItem('notifCount_{{ channel.id }}', count);
        };
    }
{% endfor %}
{% endif %}

// on récupère le nombre de notif stocké dans le local storage pour l'afficher si on change de page

{% for channel in twig_globals.getGlobals()['all_channels'] %}
    let notifCount{{ channel.id }} = document.getElementById('notifCount_{{ channel.id }}');
    if (notifCount{{ channel.id }} !== null) {
        let totalNotifCount = parseInt(localStorage.getItem('notifCount_{{ channel.id }}')) || 0;
        let eventSourceNotifCount = parseInt(notifCount{{ channel.id }}.getAttribute('data-count')) || 0;
        let currentNotifCount = totalNotifCount - eventSourceNotifCount;
        
        if (currentNotifCount > 0) {
            notifCount{{ channel.id }}.textContent = currentNotifCount;
            notifCount{{ channel.id }}.classList.remove('hideElement');
        } else {
            notifCount{{ channel.id }}.textContent = '';
            notifCount{{ channel.id }}.classList.add('hideElement');
        }
    }
{% endfor %}

// on met le compteur du channel à 0 quand l'utilisateur clique sur le lien du channel
const channelLinks = document.querySelectorAll('a[href*="channel"]');

channelLinks.forEach((link) => {
    link.addEventListener('click', (e) => {
        const notifCount = e.target.nextElementSibling; // le span qui contient le nombre de notif
        // on met le compteur du channel à 0 dans le local storage au clic sur le lien du channel
        notifCount.setAttribute('data-count', 0);
        localStorage.setItem(notifCount.id, 0);
        notifCount.textContent = '';
        notifCount.classList.add('hideElement');
    });
});


//////////////////// CONVERSATIONS PRIVEES //////////////////////

//TODO si l'utilisateur en session n'est pas dans le tableau des id des participants, on ne doit pas afficher la conversation.
// seul les participants doivent pouvoir accéder à la conversation et la voir.

// Récupérer la liste des utilisateurs
const userList = document.querySelectorAll('li[data-id]');

// Ajouter un écouteur d'événements sur chaque utilisateur
userList.forEach( user => {
  user.addEventListener('click', (e) => {
    
   // e.preventDefault();
    // Récupérer l'ID de l'utilisateur sélectionné et le convertir en int
    const userId = parseInt(user.dataset.id);
    console.log(userId);
    // Envoyer une requête fetch à la route /conversation avec l'ID de l'utilisateur sélectionné
    fetch('/conversation', {
      method: 'POST',
      body: JSON.stringify({ participants: [ userId ] }), // ici je passe un array parce que dans le bac on fait un count sur le nombre d'éléments dans le tableau pour si le nombre de participants invités est conforme au nombre de participants attendus
      headers: {
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur lors de la récupération des données');
      }
      return response.json();
    })
    .then(data => {
      // Faire quelque chose avec les données récupérées
      // console.log(data.conversation);
      displayConversation(data.conversation);
    })
    .catch(error => {
      console.error(error);
    });
  });
});

////////////////////// RECUPERER LA LISTE DES CONVERSATIONS PRIVEES D'UN UTILISATEUR //////////////////////
function returnUserConversations(id) {
    return paserInt(id);
}


// Récupérer l'ID de l'utilisateur en session
function getUserConversations() {
const userId = '{{ app.user.id }}';
    if (userId) {
        // Envoyer une requête fetch à la route /conversation avec l'ID de l'utilisateur en session
        fetch(`user/${userId}/conversation/`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Erreur lors de la récupération des données');
            }
            return response.json();
        })
        .then(data => {
            // Faire quelque chose avec les données récupérées
            console.log(data.conversations);
            // display the list of conversations
            const conversationsList = document.getElementById('conversationsList');
            data.conversations.forEach( conversation => {
                const li = document.createElement('li');
                li.textContent = conversation.id;
                conversationsList.appendChild(li);
            });
        })
        .catch(error => {
            console.error(error);
        });
    }
}


////////////////// RECUPERER LA CONVERSATION EN COURS ENTRE DEUX USERS //////////////////////
function getUserConversationsId(id) {   
    return fetch('/conversation/' + id)
        .then(response => {
            if (!response.ok) {
                throw new Error('Erreur lors de la récupération des données');
            }
            return response.json();
        })
        .then(data => {
            return data.conversations;
        })
        .catch(error => {
            console.error(error);
        });
};

///////// PRIVATE MERCURE TOPIC BETWEN TWO USERS ///////////

const privateTopicslink = new URL('https://mercure.simschab.cloud/.well-known/mercure');
privateTopicslink.searchParams.append('topic', encodeURIComponent('private/' + conversation.id));


///////// AFFICHAGE ET MISE A JOUR DE LA CONVERSATION ENTRE DEUX USER ///////////
 
function displayConversation(conversation) {
    console.log(conversation);

    // on récupère l'id de l'utilisateur en session
    const sessionUserId = '{{ app.user.id }}';
    // on récupère l'id de l'utilisateur avec qui on discute
    const otherUserId = conversation.users.filter( user => user !== sessionUserId)[0];
    // on récupère le nom de l'utilisateur avec qui on discute

}

</script>
{% endblock %}

