<aside>
<div>
    <h2>ChatRooms</h2>
</div>

{# on ajoute la liste des utilisateurs connectés #}
<div class="mb-3">
{% if twig_globals.getGlobals()['online_users'] is not empty %}
    <ul class ="user_connected_list">
    {% for online_user in twig_globals.getGlobals()['online_users'] %}
        <li data-id={{ online_user.id  }}>{{ online_user.username }} : online</li>
    {% endfor %}
    {% else %}
    <li>
        Aucun utilisateur connecté
    </li>
{% endif %}
    </ul>
</div>


<div>
{% if twig_globals.getGlobals()['all_channels'] is not empty %}
    <ul class="notifList">
    {% for channel in twig_globals.getGlobals()['all_channels'] %}
        <li>
            <a href="{{ path('app_channel_show', {'id': channel.id}) }}">{{ channel.name }}</a>
            <span class="notifCount" id="notifCount_{{ channel.id }}" data-count=0></span>
            {# on prepare une span pour le nombre de notif...à gèrer en js 
            et renvoyer les notifs depuis le controller...#}
        </li>
    {% endfor %}
    {% else %}
        <li>
            <a href="{{ path('app_channel_new') }}">Créer un nouveau chat</a>
        </li>
    {% endif %}
    </ul>
</div>
</aside>


{% if app.user is defined and app.user is not null %}


{% block javascripts %}



<script>



    // check if the user is connected in the session as app.user or not

    /////////////////
    const topicslink = new URL('https://mercure.simschab.cloud/.well-known/mercure');
    topicslink.searchParams.append('topic', encodeURIComponent('user_connected'));
    topicslink.searchParams.append('topic', encodeURIComponent('user_disconnected'));
    // on peut imaginer ajouter d'autres topics pour les messages, les channels, etc...    
    const usersEventSource = new EventSource(topicslink);

    const usersConnectedList = document.querySelector('.user_connected_list');
    console.log(usersConnectedList);

    usersEventSource.onmessage = (e) => {
        const data = JSON.parse(e.data);
        console.log(data);
        if (data.status === 'online') {

            // cause we have boot a request from users status in database to not clear list on page change 
            // and a direct request from mercure to update the list when a user connect or disconnect
            // check fist if the user is already in the list for not adding it twice in the list

            // si on change de page ou en arrivant sur l'interface on va avoir la liste des utilisateurs connectés via la varibale globale twig et la requete en bdd
            // donc on ne veut pas faire de doublon avec la liste des utilisateurs qui se connectent et aussi ne pas perdre les utilisateurs qui se connectent si on change de page...
            const liAlreadyInList = usersConnectedList.querySelector(`li[data-id="${data.user_id}"]`);
            if (liAlreadyInList) {
                return;
            }

            const li = document.createElement('li');
            li.textContent = data.username + ' : ' + data.status;
            li.dataset.id = data.user_id;
            usersConnectedList.appendChild(li);
        } else if (data.status === 'offline') {
            const li = usersConnectedList.querySelector(`li[data-id="${data.user_id}"]`);
            li.remove();
        }
    };

///////////////// Channels notifications using mercure in a loop on all channels ////////////////

// get id from url to know which channel is currently displayed
{% if app.request.get('id') is not null %}
    const currentChannelId = {{ app.request.get('id') }};
{% else %}
    const currentChannelId = null;
{% endif %}

{% if twig_globals.getGlobals()['all_channels'] is not empty %}

{% for channel in twig_globals.getGlobals()['all_channels'] %}
    // Est ce que le channel actuellement affiché est différent de celui de la boucle ?
    if ({{ channel.id }} !== currentChannelId || currentChannelId === null) {
        // on ajoute un event source pour chaque channel différent de celui actuellement affiché
        const notifSource{{ channel.id }} = new EventSource('https://mercure.simschab.cloud/.well-known/mercure?topic=channel/{{ channel.id }}');
        // on récupère la span qui contiendra le nombre de notif
        const notifCount{{ channel.id }} = document.getElementById('notifCount_{{ channel.id }}');
        
        // on écoute les messages envoyés par mercure
        notifSource{{ channel.id }}.onmessage = (event) => {
            const data = JSON.parse(event.data);
            let count = parseInt(notifCount{{ channel.id }}.getAttribute('data-count')) || 0;
            // on incrémente le nombre de notif avec la valeur retournée par mercure à la clé count
            count += 1;
            notifCount{{ channel.id }}.textContent = count;
            notifCount{{ channel.id }}.setAttribute('data-count', count);
            notifCount{{ channel.id }}.classList.remove('hideElement');
            // on stocke le nombre de notif dans le local storage pour pouvoir le récupérer si on change de page
            localStorage.setItem('notifCount_{{ channel.id }}', count);
        };
    }
{% endfor %}
{% endif %}

// on récupère le nombre de notif stocké dans le local storage pour l'afficher si on change de page

{% for channel in twig_globals.getGlobals()['all_channels'] %}
    let notifCount{{ channel.id }} = document.getElementById('notifCount_{{ channel.id }}');
    if (notifCount{{ channel.id }} !== null) {
        let totalNotifCount = parseInt(localStorage.getItem('notifCount_{{ channel.id }}')) || 0;
        let eventSourceNotifCount = parseInt(notifCount{{ channel.id }}.getAttribute('data-count')) || 0;
        let currentNotifCount = totalNotifCount - eventSourceNotifCount;
        
        if (currentNotifCount > 0) {
            notifCount{{ channel.id }}.textContent = currentNotifCount;
            notifCount{{ channel.id }}.classList.remove('hideElement');
        } else {
            notifCount{{ channel.id }}.textContent = '';
            notifCount{{ channel.id }}.classList.add('hideElement');
        }
    }
{% endfor %}

// on met le compteur du channel à 0 quand l'utilisateur clique sur le lien du channel
const channelLinks = document.querySelectorAll('a[href*="channel"]');

channelLinks.forEach((link) => {
    link.addEventListener('click', (e) => {
        const notifCount = e.target.nextElementSibling; // le span qui contient le nombre de notif
        // on met le compteur du channel à 0 dans le local storage au clic sur le lien du channel
        notifCount.setAttribute('data-count', 0);
        localStorage.setItem(notifCount.id, 0);
        notifCount.textContent = '';
        notifCount.classList.add('hideElement');
    });
});

/////////////////////////////////////////********* SUB ************////////////////////////////////////////////
// On crée un nouvel objet EventSource, qui va se connecter au hub Mercure
function subscribe(id){
    const link = 'https://mercure.simschab.cloud/.well-known/mercure';

    const url = new URL(link);
    url.searchParams.append('topic', encodeURIComponent(`conversation/${id}`));

    const eventSource = new EventSource(url);
    console.log(eventSource);
    eventSource.onmessage = e => { 
        console.log(e.data);
    };
}


//////////////////// CONVERSATIONS PRIVEES //////////////////////

//TODO si l'utilisateur en session n'est pas dans le tableau des id des participants, on ne doit pas afficher la conversation.
// seul les participants doivent pouvoir accéder à la conversation et la voir.

// Récupérer la liste des utilisateurs
const userList = document.querySelectorAll('li[data-id]');

// Ajouter un écouteur d'événements sur chaque utilisateur
userList.forEach( user => {
  user.addEventListener('click', (e) => {
    
   // e.preventDefault();
    // Récupérer l'ID de l'utilisateur sélectionné et le convertir en int
    const userId = parseInt(user.dataset.id);
    console.log(userId);
    // Envoyer une requête fetch à la route /conversation avec l'ID de l'utilisateur sélectionné
    fetch('/conversation', {
      method: 'POST',
      body: JSON.stringify({ participants: [ userId ] }), // ici je passe un array parce que dans le bac on fait un count sur le nombre d'éléments dans le tableau pour si le nombre de participants invités est conforme au nombre de participants attendus
      headers: {
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur lors de la récupération des données');
      }
      return response.json();
    })
    .then(data => {
      // Faire quelque chose avec les données récupérées
      // console.log(data.conversation);
      displayConversation(data.conversation);
      subscribe(data.conversation.id);
    })
    .catch(error => {
      console.error(error);
    });
  });
});

////////////////////// RECUPERER LA LISTE DES CONVERSATIONS PRIVEES D'UN UTILISATEUR //////////////////////
function returnUserConversations(id) {
    return paserInt(id);
}


// Récupérer l'ID de l'utilisateur en session
function getUserConversations() {

    if (userId) {
        // Envoyer une requête fetch à la route /conversation avec l'ID de l'utilisateur en session
        fetch(`user/${userId}/conversation/`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Erreur lors de la récupération des données');
            }
            return response.json();
        })
        .then(data => {
            // Faire quelque chose avec les données récupérées
            console.log(data.conversations);
            // display the list of conversations
            const conversationsList = document.getElementById('conversationsList');
            data.conversations.forEach( conversation => {
                const li = document.createElement('li');
                li.textContent = conversation.id;
                conversationsList.appendChild(li);
            });
        })
        .catch(error => {
            console.error(error);
        });
    }
}


////////////////// RECUPERER LA CONVERSATION EN COURS ENTRE DEUX USERS //////////////////////
function getUserConversationsId(id) {   
    return fetch('/conversation/' + id)
        .then(response => {
            if (!response.ok) {
                throw new Error('Erreur lors de la récupération des données');
            }
            return response.json();
        })
        .then(data => {
            return data.conversations;
        })
        .catch(error => {
            console.error(error);
        });
};

///////// PRIVATE MERCURE TOPIC BETWEN TWO USERS ///////////

//const privateTopicslink = new URL('https://mercure.simschab.cloud/.well-known/mercure');
//privateTopicslink.searchParams.append('topic', encodeURIComponent('private/' + conversation.id));


///////// AFFICHAGE ET MISE A JOUR DE LA CONVERSATION ENTRE DEUX USER ///////////
 
function displayConversation(conversation) {

    console.log(conversation);

    const sessionUserId = parseInt('{{ app.user.id }}');
    const sessionUserName = '{{ app.user.username }}';
    console.log(`user en session : ${sessionUserId}`);
    console.log(`nom du user en session : ${sessionUserName}`);

    // on récupère l'id de l'utilisateur avec qui on discute
    // récupèrer dans le tableau conversation.users l'id de l'utilisateur qui n'est pas égal à l'id de l'utilisateur en session sessionUserId
    const otherUserId = conversation.users.find( user => parseInt(user.id) !== sessionUserId);
    console.log(`participant : ${otherUserId.id}`);

    // on récupère le nom de l'utilisateur avec qui on discute
    const otherUserName = otherUserId.username;
    console.log(`nom du participant : ${otherUserName}`);

    // on récupère l'id de la conversation
    const conversationId = conversation.id;
    console.log(`conversation : ${conversationId}`);

    // on récupère les mesages de la conversation si il y en a sinon on retourne un tableau vide
    const messages = conversation.messages ? conversation.messages : [];

    // on récupère les elements du DOM
    const sendPrivateMessageBtn = document.getElementById('sendPrivateMessage');

    
    // on écoute le click sur le bouton d'envoi de message
    sendPrivateMessageBtn.addEventListener('click', (e) => {
        
        console.log('click');
        e.preventDefault();
        // on récupère le contenu du message
        const messageContent = document.getElementById('chatBoxInput').value;
        console.log(messageContent);
        // on ajoute le message à la fenêtre de chat si il est posté par le user en session il est à droite sinon il est à gauche
        if (sessionUserId === otherUserId.id) {
            addMessageToChatBox(messageContent, sessionUserName, 'left', '#d0e8f5');
        } else {
            addMessageToChatBox(messageContent, otherUserName, 'right', '#d0f5e3');
        }
    });

    function addMessageToChatBox(message, user, floatSide, backGroundColor){
        console.log('addMessageToChatBox');
        // on récupère la fenêtre de chat
        const chatBox = document.getElementById('chatBoxBody');
        // on crée un élément div
        const messageDiv = document.createElement('div');
        // on ajoute la classe message à l'élément div
        messageDiv.classList.add('private_message');
        // on ajoute la classe float à l'élément div
        messageDiv.style.float = floatSide;
        messageDiv.style.backgroundColor = backGroundColor;
        // on crée un élément p
        const messageP = document.createElement('span');
        // on ajoute le contenu du message à l'élément p
        messageP.textContent = `${user} : ${message}` ;
        // on ajoute l'élément p à l'élément div
        messageDiv.appendChild(messageP);
        // on ajoute l'élément div à la fenêtre de chat
        chatBox.appendChild(messageDiv);
        // on vide le champ de saisie
        document.getElementById('chatBoxInput').value = '';
        // on poste le message au serveur
        postPrivateMessage(message, conversationId, sessionUserId);
    } 

    function postPrivateMessage(message, conversationId, sessionUserId) {

        const data = {  
        topic: encodeURIComponent(`conversation/${conversationId}`),
        message: `${message}`,
        conversation_id: `${conversationId}`,
        author_id: `${sessionUserId}`,
        };
        
        fetch('/publish/private', {
        method: 'POST',
        body: JSON.stringify(data),
        })
        .then(response => response.text())
        .then(data => {
            console.log('Message privé envoyé');
        })
        .catch(error => {
            console.error(error);
        });

    }



    
}

</script>


{% endblock %}


{% endif %}